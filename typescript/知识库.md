```原始类型```：Number，String，Boolean，null，undefined，Symbol
```引用类型```：Array，Function，Object
ts在ES6的数据类型基础上，新增了以下数据类型:```void, any, never, 元组，枚举，高级类型```

## 一、类型
### 1.1 Number类型
```ts
let cml: number = 1
// es5: let cml = 1
```

### 1.2 String类型
```ts
let cml: string = '1'
// es5: let cml = '1'
```
### 1.3 Boolean类型
```ts
let cml: boolean = true
// es5: let cml = true
```

### 1.4 Null类型
```ts
let cml:null = null
// es5: let cml = null
```

### 1.5 Undefined类型
```ts
let cml:undefined = undefined
// es5: let cml = undefined
```

### 1.6 Symbol类型
```ts
const sym = Symbol();
let obj = {
  [sym]: "cml",
};

console.log(obj[sym]); // cml
```
### 1.7 Void类型
void类型可以被赋值为undefined和null，但是不能被赋值其他的，比如string
```ts
let cml:void = undefined
// es5: let cml = undefined
cml = null
```
```小结:```ts会做静态类型检查，当一个变量被定义了某种类型后，再赋值为其他类型的值时，则会有报错提示
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b143a5ac2ec4f97b300758fb01aaf77~tplv-k3u1fbpfcp-watermark.image)

```但是```当被重新赋值为null和undefined时，则不会报错，我因为null和undefined可以看成是所有类型的子集
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c296484da6f14e08ad26dfa66aa4ed01~tplv-k3u1fbpfcp-watermark.image)
### 1.8 数组
```1 类型+方括号```
```ts
let cml: number[] = [1, 2, 3]
// es5: let web = [1, 2, 3]
let web: any[] = [1, '2', true]

```

```2 泛型```
```ts
let cml: Array<number> = [1, 2, 3]
// es5: let cml = [1, 2, 3]
```

3 接口

类数组： 内置对象：IArguments, NodeList, HTMLCollection
```ts
function web(name: string, age: number) {
  let args: IArguments = arguments;
  console.log(args);  // { '0': 'web', '1': 1 }
}
web('web', 1)
```

### 1.9 元组
```ts
let cml: [string, number] = ['666', 666]
console.log(p) // [ '666', 666 ]
```
使用```下标```的方式，可以只对其中一项赋值，但是对```整个对象```赋值时，必须是完整的，且类型不能错，个数不能多也不能少
```ts
let cml: [string, number] = ['666', 666]
cml[0] = '888'
console.log(cml) // ['888', 666]
cml[1] = 888
console.log(cml) // ['888', 888]
cml = ['888', 888]
console.log(cml) // ['888', 888]
cml = ['888', 888, '888'] // 报错
```
可以通过push的方式放入更多的元素
```ts
let cml: [string, number] = ['666', 666]
cml.push('888')
console.log(cml) // ['666', 666, '888']
```

### 1.10 any类型
any类型可以任意赋值，不写相当于any
```ts
let cml:any = '123'
cml = 123
```
### 1.11 联合类型
```ts
let cml:string | number
cml = '123'
cml = 123
```
```类型断言```
是针对联合类型，可以通过断言为变量指定一个类型
```ts
function cml(a: number | string): void {
  console.log(a.length) // 报错
  console.log((<string>a).length) // OK
}
```
```类型别名```
除了规定的string/number等类型，ts还支持自定义类型
```ts
type Cml = '666' | '888'
function cmlFun(a: Cml): void {
  console.log(a)
}
cmlFun('666') // OK
cmlFun(666) // 报错
```
### 1.12 enum枚举类型
基本用法
```ts
enum Gender {Male, Female}
console.log(Gender) // {'0': 'Male', '1': 'Female', 'Male': 0, 'Female', 1}
console.log(Gender['0']) // Male
console.log(Gender['1']) // FeMale
console.log(Gender['Male']) // 0
console.log(Gender['Female']) // 1
```
对应的ES5的写法
```ts
// typescript
enum Gender {Male, Female}

// ES5
var Gender;
(function (Gender) {
    Gender[Gender["Male"] = 0] = "Male";
    Gender[Gender["Female"] = 1] = "Female";
})(Gender || (Gender = {}));
```

 数字的枚举
```ts
enum Direction {
  NORTH, // 默认0
  SOUTH, // 默认1
  EAST, // 默认2
  WEST, // 默认3
}
let dir: Direction = Direction.EAST;
console.log('dir', dir) // 2
```
默认为0,1,2,3...，如果自定义数字，则后面的枚举在前一个枚举值上递增

```ts
enum Direction1 {
  NORTH = -1,
  SOUTH, // 变成0
  EAST = 4,
  WEST, // 变成5
}
```

## 二、接口
### 1. 确定属性
```ts
// 定义一个接口
interface IPerson {
  name: string,
  age: number
}

// 实例化
let p1: IPerson = {
  name: 'web',
  age: 18
}
```
一个变量，如上面的p1，如果被声明为某一种接口的实例，则变量拥有的属性必须要和接口定义的一样，不能多也不能少，否则会报错。

### 2. 可选属性
```ts
interface IPerson {
  name: string,
  age?: number
}

// 实例化
let p1: IPerson = {
  name: 'web',
}
```
### 3. 任意属性
```ts
interface IPerson {
  name: string,
  [propName: string]: boolean | string
}

let p1: IPerson = {
  name: '123',
  married: false, // ok
  country: '123' // ok
  age: 123 // 报错
}
```
如果设定了任意属性，那么所有的确定属性或者可选属性必须是任意属性的子集。

### 4. 只读属性
```ts
interface IPerson {
  readonly name: string,
  age: number
}

let p1: IPerson = {
  name: '123',
  age: 18
}

let p2: IPerson = {
  name: '456', // ok
  age: 18
}

p1.name = '456' // 报错
p1.age = 18
```
readonly，指的是如果不在每次对象赋值情况下，是不能修改值的。


## 三、函数
### 1. 基本用法
ES5里函数的声明和函数的表达式
```ts
// 函数的声明
function cml(x, y) {
  return x + y
}
console.log(cml(1, 2))  // 3

// 函数的表达式
let cml = function(x, y) {
  return x + y
}
console.log(cml(1, 2))  // 3
```
```ts里函数的声明```
```ts
function cml(x: number, y: number): number {
  return x + y
}
console.log(cml(1, 2))  // 3
```
```ts里函数的表达式```
```ts
let cml = function(x: number, y: number): number {
  return x + y
}
console.log(cml(1, 2))  // 3
```
但其实这里没有给cml定义函数的类型，完整的写法是这样的
```ts
let cml: (x: number, y: number) => number = function(x: number, y: number): number {
  return x + y
}
console.log(cml(1, 2))  // 3
```
函数的类型也可以写成接口的形式
```ts
interface ICml {
  (x: number, y: number): number
}

let cml: ICml = function(x: number, y: number) : number {
  return x + y
}
console.log(cml(1, 2))  // 3
```

### 2.可选参数
一个可选参数后面不能再有确定(必须)参数
```ts
function cml(x: number, y?: number): number {
  y = y || 0
  return x + y
}
console.log(cml(1, 2))  // 3
console.log(cml(1))  // 1
```

### 3.剩余参数
回忆一下ES5里的arguments和ES6里的args
```ES5的arguments```
```ts
function cml() {
  let sum = 0
  for(let item of arguments) {
    sum = sum + item
  }
  return sum
}
console.log(cml(1, 2, 3)) // 6
```
```ES6的args```
```ts
function cml(...args) {
  let sum = 0
  for(let item of args) {
    sum = sum + item
  }
  return sum
}
console.log(cml(1, 2, 3)) // 6
```

```ts里的剩余参数```
```ts
function cml(...args: number[]) {
  let sum: number = 0
  for(let i: number = 0; i < args.length; i ++) {
    sum = sum + args[i]
  }
  return sum
}
console.log(cml(1, 2, 3)) // 6
console.log(cml(1, '2', 3)) // 报错
```

