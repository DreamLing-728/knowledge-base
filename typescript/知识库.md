```原始类型```：Number，String，Boolean，null，undefined，Symbol
```引用类型```：Array，Function，Object
ts在ES6的数据类型基础上，新增了以下数据类型:```void, any, never, 元组，枚举，高级类型```

## 一、类型
### 1.1 Number类型
```ts
let cml: number = 1
// es5: let cml = 1
```

### 1.2 String类型
```ts
let cml: string = '1'
// es5: let cml = '1'
```
### 1.3 Boolean类型
```ts
let cml: boolean = true
// es5: let cml = true
```

### 1.4 Null类型
```ts
let cml:null = null
// es5: let cml = null
```

### 1.5 Undefined类型
```ts
let cml:undefined = undefined
// es5: let cml = undefined
```

### 1.6 Symbol类型
```ts
const s2: symbol = Symbol(); // ts
const s1 = Symbol();  // es5
console.log(s1 === s2) // false
```
### 1.7 Void类型
void类型可以被赋值为undefined和null，但是不能被赋值其他的，比如string
```ts
let cml:void = undefined
// es5: let cml = undefined
cml = null
```
```小结:```ts会做静态类型检查，当一个变量被定义了某种类型后，再赋值为其他类型的值时，则会有报错提示
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b143a5ac2ec4f97b300758fb01aaf77~tplv-k3u1fbpfcp-watermark.image)

```但是```
1. 当被重新赋值为null和undefined时，则不会报错，因为null和undefined可以看成是所有类型的子集
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c296484da6f14e08ad26dfa66aa4ed01~tplv-k3u1fbpfcp-watermark.image)
2. 被定义为null和undefined类型的，只能赋值为它本身

### 1.8 对象
```ts
// let cml: Object = {x: 1, y: 1} // 不能直接写Object，需要具体定义包含的属性以及对应的类型
let cml: {x: number, y: number} = {x: 1, y: 1}
cml.x = 2
console.log(cml)
```
### 1.9 数组
```1 类型+方括号```
```ts
let cml: number[] = [1, 2, 3]
// es5: let web = [1, 2, 3]
let web: any[] = [1, '2', true]

```

```2 泛型```
```ts
let cml: Array<number> = [1, 2, 3]
// es5: let cml = [1, 2, 3]
```

3 接口

类数组： 内置对象：IArguments, NodeList, HTMLCollection
```ts
function web(name: string, age: number) {
  let args: IArguments = arguments;
  console.log(args);  // { '0': 'web', '1': 1 }
}
web('web', 1)
```

### 1.10 元组
元组是一种特殊的数组，限定了数组的类型和个数
```ts
let cml: [string, number] = ['666', 666]
console.log(cml) // [ '666', 666 ]
```
使用```下标```的方式，可以只对其中一项赋值，但是对```整个对象```赋值时，必须是完整的，且类型不能错，个数不能多也不能少
```ts
let cml: [string, number] = ['666', 666]
cml[0] = '888'
console.log(cml) // ['888', 666]
cml[1] = 888
console.log(cml) // ['888', 888]
cml = ['888', 888]
console.log(cml) // ['888', 888]
cml = ['888', 888, '888'] // 报错
```
元组的越界：可以通过push的方式放入更多的元素，可以push，但是仍然不能访问
```ts
let cml: [string, number] = ['666', 666]
cml.push('888')
console.log(cml) // ['666', 666, '888']
console.log(cml[2]) // 报错
```

### 1.11 any类型
any类型可以任意赋值，不写相当于any
```ts
let cml:any = '123'
cml = 123
```

### 1.12 never类型
never 类型表示的是那些永不存在的值的类型。例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式。
```ts
// 抛出异常的函数
let error: never = () => {
  throw new Error('error')
}

// 死循环函数
let endLess: never = () => {
  while(true) {}
}
```
### 1.13 联合类型
```ts
let cml:string | number
cml = '123'
cml = 123
```
```类型断言```
是针对联合类型，可以通过断言为变量指定一个类型
```ts
function cml(a: number | string): void {
  console.log(a.length) // 报错
  console.log((<string>a).length) // OK
}
```
```类型别名```
除了规定的string/number等类型，ts还支持自定义类型
```ts
type Cml = '666' | '888'
function cmlFun(a: Cml): void {
  console.log(a)
}
cmlFun('666') // OK
cmlFun(666) // 报错
```
### 1.14 enum枚举类型
#### 1. 基本用法
```ts
enum Gender {Male, Female}
console.log(Gender) // {'0': 'Male', '1': 'Female', 'Male': 0, 'Female', 1}
console.log(Gender['0']) // Male
console.log(Gender['1']) // FeMale
console.log(Gender['Male']) // 0
console.log(Gender['Female']) // 1
```
对应的ES5的写法
```ts
// typescript
enum Gender {Male, Female}

// ES5
var Gender;
(function (Gender) {
    Gender[Gender["Male"] = 0] = "Male";
    Gender[Gender["Female"] = 1] = "Female";
})(Gender || (Gender = {}));
```

#### 2. 数字的枚举
```ts
enum Direction {
  NORTH, // 默认0
  SOUTH, // 默认1
  EAST, // 默认2
  WEST, // 默认3
}
let dir: Direction = Direction.EAST;
console.log('dir', dir) // 2
```
默认为0,1,2,3...，如果自定义数字，则后面的枚举在前一个枚举值上加1

```ts
enum Direction1 {
  NORTH = -1,
  SOUTH, // 变成0
  EAST = 4,
  WEST, // 变成5
}
```
注意，自加的枚举数值，不保证和已经设定的数值不重合
```ts
enum Direction1 {
  NORTH = 1,
  SOUTH = 0,
  EAST,
  WEST,
}
console.log(Direction1)
```
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9186adfac53347e0abee7e2859e5bc9d~tplv-k3u1fbpfcp-watermark.image)

也可以把数字变成小数
```ts
enum Direction1 {
  NORTH = 1.5,
  SOUTH, // 2.5
  EAST, // 3.5
  WEST, // 4.5
}
console.log(Direction1)
```
#### 3. 字符串的枚举
```ts
enum Direction1 {
  NORTH = 'a',
  SOUTH = 'b', 
  EAST = 'c', 
  WEST = 'd', 
}
console.log(Direction1)  // { NORTH: 'a', SOUTH: 'b', EAST: 'c', WEST: 'd' }
console.log(Direction1['NORTH']) // a
console.log(Direction1['a'])  // undefined
```

#### 4. 常量枚举
常量枚举是它是使用```const```关键字修饰的枚举,普通枚举有对象，常量枚举没有对象，对象实体只存在于TS中，当翻译为ES5代码时，被删除了。

用途：当我们不需要这个对象，只需要对象里的值时，适用常量枚举，可以减少编译时的代码
```ts
// ts 代码
const enum Gender {Male, Female}
let cml: Gender = Gender['Female']
console.log(cml)  // 1

// ES5 代码
var cml = 1 /* 'Female' */;
console.log(cml);
```

#### 5. 异构枚举
异构枚举的成员值是数字和字符串的混合：
```ts
enum Cml {
  A,
  B,
  C = "c",
  D = "d",
  E = 8,
  F,
}
```
数字枚举和字符串枚举不同的是，数字枚举相对字符串枚举多了 “反向映射”：
```ts
console.log(Cml[0]) // A
console.log(Cml['A']) // 0
console.log(Cml['C']) // c
console.log(Cml['c']) // undefined
```
## 二、接口
### 1. 确定属性
```ts
// 定义一个接口
interface IPerson {
  name: string,
  age: number
}

// 实例化
let p1: IPerson = {
  name: 'web',
  age: 18
}
```
一个变量，如上面的p1，如果被声明为某一种接口的实例，则变量拥有的属性必须要和接口定义的一样，不能多也不能少，否则会报错。

### 2. 可选属性
```ts
interface IPerson {
  name: string,
  age?: number
}

// 实例化
let p1: IPerson = {
  name: 'web',
}
```
### 3. 任意属性
```ts
interface IPerson {
  name: string,
  [propName: string]: boolean | string
}

let p1: IPerson = {
  name: '123',
  married: false, // ok
  country: '123' // ok
  age: 123 // 报错
}
```
如果设定了任意属性，那么所有的确定属性或者可选属性必须是任意属性的子集。

### 4. 只读属性
```ts
interface IPerson {
  readonly name: string,
  age: number
}

let p1: IPerson = {
  name: '123',
  age: 18
}

let p2: IPerson = {
  name: '456', // ok
  age: 18
}

p1.name = '456' // 报错
p1.age = 18
```
readonly，指的是如果不在每次对象赋值情况下，是不能修改值的。


## 三、函数
### 1. 基本用法
ES5里函数的声明和函数的表达式
```ts
// 函数的声明
function cml(x, y) {
  return x + y
}
console.log(cml(1, 2))  // 3

// 函数的表达式
let cml = function(x, y) {
  return x + y
}
console.log(cml(1, 2))  // 3
```
```ts里函数的声明```
```ts
function cml(x: number, y: number): number {
  return x + y
}
console.log(cml(1, 2))  // 3
```
```ts里函数的表达式```
```ts
let cml = function(x: number, y: number): number {
  return x + y
}
console.log(cml(1, 2))  // 3
```
但其实这里没有给cml定义函数的类型，完整的写法是这样的
```ts
let cml: (x: number, y: number) => number = function(x: number, y: number): number {
  return x + y
}
console.log(cml(1, 2))  // 3
```
函数的类型也可以写成接口的形式
```ts
interface ICml {
  (x: number, y: number): number
}

let cml: ICml = function(x: number, y: number) : number {
  return x + y
}
console.log(cml(1, 2))  // 3
```

### 2.可选参数
一个可选参数后面不能再有确定(必须)参数
```ts
function cml(x: number, y?: number): number {
  y = y || 0
  return x + y
}
console.log(cml(1, 2))  // 3
console.log(cml(1))  // 1
```

### 3.剩余参数
回忆一下ES5里的arguments和ES6里的args
```ES5的arguments```
```ts
function cml() {
  let sum = 0
  for(let item of arguments) {
    sum = sum + item
  }
  return sum
}
console.log(cml(1, 2, 3)) // 6
```
```ES6的args```
```ts
function cml(...args) {
  let sum = 0
  for(let item of args) {
    sum = sum + item
  }
  return sum
}
console.log(cml(1, 2, 3)) // 6
```

```ts里的剩余参数```
```ts
function cml(...args: number[]) {
  let sum: number = 0
  for(let i: number = 0; i < args.length; i ++) {
    sum = sum + args[i]
  }
  return sum
}
console.log(cml(1, 2, 3)) // 6
console.log(cml(1, '2', 3)) // 报错
```

## 四、类和接口


